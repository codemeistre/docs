#!/usr/bin/env -S npx zx
// ##
// #% SYNOPSIS
// #%    update-db-diagram.mjs
// #% DESCRIPTION
// #%    Script to download the Relational Model Diagram and update the 'docs'
// #%    Git repository to push that new version. The downloaded file will be
// #%    encrypted by https://www.npmjs.com/package/staticrypt using a secret.
// #% NOTE
// #%    Required programs: npx, git(1), tail(1), head(1)
// #%    This code uses the https://github.com/google/zx utility.
// #% AUTHOR
// #%    Micael Levi L. Cavalcante
// #% COPYRIGHT
// #%    Copyright © 2022 CodeMeistre.
// ##
const IS_VERBOSE = process.env.NODE_ENV === 'development'
$.shell = '/usr/bin/bash'
$.verbose = IS_VERBOSE

import path from 'node:path'
import crypto from 'node:crypto'
import { pipeline } from 'node:stream/promises'

/** */
const PLANTUML_BASE_URL = 'https://www.plantuml.com/plantuml'
/** Path to where the `.git` lives relative to this script file. */
const PATH_REPOSITORY_DOCS=path.join(__dirname, '..')
const REPOSITORY_REMOTE_NAME = 'origin'
const REPOSITORY_TARGET_BRANCH = 'master'
/** Path to where the private diagrams lives relative to this script file. */
const PATH_PRIVATE_DIAGRAMS=path.join(__dirname, '..', 'private-diagrams')
const DATABASE_SPEC_DIAGRAM_FILENAMENAME='database_spec.relational-model.html'
const DATABASE_CURRENT_DIAGRAM_FILENAMENAME='database.relational-model.html'
/** Random value generated by $ npx staticrypt --salt */
const CRYPT_SALT = '87f68ea40d949395e2bd764cc127d086'


const url = await question(
  chalk.bold.bgBlack('→ URL para o arquivo SVG ou para a página do editor (do PlantUML): ')
).then(answer => answer.trim())
if (!url) {
  console.error( chalk.bold.red('A URL não pode ser vazia!') )
  process.exit(1)
}
// NOTE: The following two replaces are assuming that the format of `url` variable
//       will have a "/uml/" to indicates that it is an URL to the PlantUML editor,
//       or it will have a "/svg/" to indicates that it is an URL to the SVG file.
const normalized_url = url.replace('/svg/', '/uml/').replace('/png/', '/uml/').replace('/txt/', '/uml/')
const diagram_code = normalized_url.slice(normalized_url.indexOf('/uml/') + '/uml/'.length)
const diagram_svg_url = `${PLANTUML_BASE_URL}/svg/${diagram_code}`
const diagram_editor_url = `${PLANTUML_BASE_URL}/uml/${diagram_code}`

const page_passphrase = await question(
  chalk.bold.bgBlack('→ Senha para criptografar o arquivo anterior: ')
)

let page_title, full_path_to_diagram_file;
const currTime = new Intl.DateTimeFormat('pt-BR', {
  hour12:false, timeZone:'America/Manaus',
  year:'numeric', month:'numeric', day:'numeric',
  hour:'numeric', minute:'numeric'
}).format(new Date())

page_title = `(spec.) DB Relational Model ${currTime}`
full_path_to_diagram_file = path.join(PATH_PRIVATE_DIAGRAMS, DATABASE_SPEC_DIAGRAM_FILENAMENAME)

const svg_tmp_file = `${Date.now()}.svg`
const html_tmp_file = `${Date.now()}.html`
async function cleanupAndExit() {
  if (cleanupAndExit.done) return; 
  await Promise.allSettled([
    fs.rm(svg_tmp_file, { force: true }),
    fs.rm(html_tmp_file, { force: true }),
  ])
  cleanupAndExit.done = true // memoize
  process.exit()
}
process.once('SIGINT', cleanupAndExit)
process.once('beforeExit', cleanupAndExit)
process.once('uncaughtException', cleanupAndExit)

// Download the diagram as a SVG temporary file that will be embedded into the HTML
console.log(chalk.black.bgYellow('Baixando SVG...'))
try {
  const resp = await fetch(diagram_svg_url)
  if (!resp.ok) throw new Error('Something went wrong while downloading the SVG file')
  await pipeline(resp.body, fs.createWriteStream(svg_tmp_file))
} catch (err) {
  if (err.errno === 'ENOTFOUND') console.error( chalk.bold.black('A URL informada não foi resolvida!') )
  else if (err.code === 'ERR_INVALID_URL') console.error( chalk.bold.red(`A URL está inválida: "${err.input}"`) )
  else console.error( chalk.bold.red(err.message || err) )
  process.exit()
}
console.log(chalk.black.bgGreen('Feito!'))

// Refreshs the Git repository
await cd(PATH_REPOSITORY_DOCS)
$.verbose = true
await $`git pull`
$.verbose = IS_VERBOSE

// Encrypt the diagram code so we can embeded it iton the public HTML markup
// later for sumchecks purporses
const diagram_code_sha1 = crypto
  .createHmac('sha1', page_passphrase).update(diagram_code).digest('hex')

const curr_diagram_code_sha1 = fs.pathExistsSync(full_path_to_diagram_file)
  ? (await $`tail -n2 ${full_path_to_diagram_file} | head -n1`).stdout.trim()
  : undefined

if (curr_diagram_code_sha1 === diagram_code_sha1) {
  console.log(chalk.black.bgGreen('A versão que você está enviado já está no repositório, considerando a senha utilizada'))
  process.exitCode = 0
  await cleanupAndExit()
}

// Create the temporary HTML file that will be encrypted later
fs.writeFileSync(html_tmp_file, `
<!DOCTYPE html>
<html>
  <body>
    <div>
      <a href="${diagram_editor_url}" style="opacity: 20%;">EDIT (${currTime})</a>
    </div>
   ${ fs.readFileSync(svg_tmp_file, { encoding: 'utf8' }) }
  </body>
`.trim())


// Encrypt the downloaded HTML/SVG file
console.log(chalk.black.bgYellow('Gerando HTML criptografado...'))
await $`npx staticrypt ${html_tmp_file} ${page_passphrase} --salt ${CRYPT_SALT} --embed --title ${page_title} --output ${full_path_to_diagram_file}`
console.log(chalk.black.bgGreen('Feito!'))
const final_html_file_stream = fs.createWriteStream(full_path_to_diagram_file, { flags: 'a' })
final_html_file_stream.end(`
<!--sha1:
${diagram_code_sha1}
-->
`.trim())
final_html_file_stream.close()


const open_generated_page = await question(
  chalk.bold.bgBlack(`→ Deseja ver como ficou (abrirá com o Firefox)? ${chalk.dim('[yN]')}: `),
)
  .then((answer) => {
    // Abort if neither 'y' nor 'n' (insensitive casse) was supplied
    answer = (answer || 'n').trim().at(0).toLowerCase()
    if (!['y', 'n'].includes(answer)) process.exit()
    return answer === 'y'
  })
if (open_generated_page) await $`firefox ${full_path_to_diagram_file}`

// Commit and pushes the changes to remote
await cd(PATH_REPOSITORY_DOCS)
await $`git add ${full_path_to_diagram_file}`
await $`git commit ${['-m', 'docs: update ' + page_title]}`
await $`git push ${REPOSITORY_REMOTE_NAME} ${REPOSITORY_TARGET_BRANCH}`
console.log(chalk.black.bgGreen('Enviado pra deploy!'))
